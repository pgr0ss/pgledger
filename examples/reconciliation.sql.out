-- This file contains the sql queries plus their output, but we set the filetype to sql for better syntax highlighting
-- vim: set filetype=sql:

-- This is a fully working example script that shows reconcilation strategies.
--
-- Note that it uses `\gset` to store sql responses as variables. For example,
-- `\gset foo_` creates variables for each column in the response like
-- `foo_col1`, `foo_col2`, etc. These variables can then be used like
-- `:'foo1_col`.
-- The entire script can be passed to psql. If you are running postgres via the
-- pgledger docker compose, you can run this script with:
--
--   cat reconciliation.sql | \
--     docker compose exec --no-TTY postgres psql -U pgledger --echo-queries --no-psqlrc
--
-- The goal of this script is to show some reconcilation examples. Reconcilation is the process
-- by which we check that our view of the world matches what we expect.
-- Let's start with a simple payment flow example, similar to the basic-example.sql script:
SELECT id FROM pgledger_create_account('user1.external', 'USD') \gset user1_external_
SELECT id FROM pgledger_create_account('user1.receivables', 'USD') \gset user1_receivables_
SELECT id FROM pgledger_create_account('user1.available', 'USD') \gset user1_available_
SELECT id FROM pgledger_create_account('user1.pending_outbound', 'USD') \gset user1_pending_outbound_
-- The first step in the flow is the user initiates a $50 payment, and we are
-- waiting for funds to arrive. The difference this time is we'll use some
-- metadata to help us track what's going on:
SELECT * FROM pgledger_create_transfer(
    :'user1_external_id',
    :'user1_receivables_id',
    50.00,
    metadata => '{"payment_id": "p_123"}'
);
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |           event_at            |        metadata         
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+-------------------------------+-------------------------
 pglt_01K8M3Y0B1ENRV6VNFR6JMAXQD | pgla_01K8M3Y0AYFZ1BZN63V0H8EENB | pgla_01K8M3Y0AZFG2SMJFVC09BK2NH |  50.00 | 2025-10-28 00:36:49.120496+00 | 2025-10-28 00:36:49.120496+00 | {"payment_id": "p_123"}
(1 row)

-- The user also creates another $50 payment:
SELECT * FROM pgledger_create_transfer(
    :'user1_external_id',
    :'user1_receivables_id',
    50.00,
    metadata => '{"payment_id": "p_456"}'
);
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |           event_at            |        metadata         
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+-------------------------------+-------------------------
 pglt_01K8M3Y0B2E8KTNAJA0ZHDM8Y7 | pgla_01K8M3Y0AYFZ1BZN63V0H8EENB | pgla_01K8M3Y0AZFG2SMJFVC09BK2NH |  50.00 | 2025-10-28 00:36:49.121945+00 | 2025-10-28 00:36:49.121945+00 | {"payment_id": "p_456"}
(1 row)

-- Next, the funds arrive in our account for one of the payments, so we remove
-- them from receivables and make them available:
SELECT * FROM pgledger_create_transfer(
    :'user1_receivables_id',
    :'user1_available_id',
    50.00,
    metadata => '{"payment_id": "p_456"}'
);
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |           event_at            |        metadata         
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+-------------------------------+-------------------------
 pglt_01K8M3Y0B2F7ZBDYE71P95VRHQ | pgla_01K8M3Y0AZFG2SMJFVC09BK2NH | pgla_01K8M3Y0B0E2E8G38C8N1CBKXK |  50.00 | 2025-10-28 00:36:49.122481+00 | 2025-10-28 00:36:49.122481+00 | {"payment_id": "p_456"}
(1 row)

-- Now, we can query the receivables account and see that the balance is still
-- $50, meaning we are waiting on more funds to arrive:
SELECT balance FROM pgledger_accounts_view
WHERE id =:'user1_receivables_id';
 balance 
---------
   50.00
(1 row)

-- But how do we know which payment we're still waiting for? If we use metadata
-- on each transfer which ties it to a payment_id, then we can do interesting
-- rollups, such as summing entries by payment_id. Any payment we've received
-- funds for will zero out (since the incoming $50 and outgoing -$50 sum to 0):
SELECT
    metadata ->> 'payment_id' AS payment_id,
    sum(amount) AS sum
FROM pgledger_entries_view
WHERE account_id =:'user1_receivables_id'
GROUP BY 1;
 payment_id |  sum  
------------+-------
 p_123      | 50.00
 p_456      |  0.00
(2 rows)

-- This strategy can help us find other issues, such as when the amount of
-- funds we received weren't what we expectd. For example, say we eventually
-- received the funds for the first payment but it was short:
SELECT * FROM pgledger_create_transfer(
    :'user1_receivables_id',
    :'user1_available_id',
    49.50,
    metadata => '{"payment_id": "p_123"}'
);
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |           event_at            |        metadata         
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+-------------------------------+-------------------------
 pglt_01K8M3Y0B3EZ89BYV9W8K4FS4H | pgla_01K8M3Y0AZFG2SMJFVC09BK2NH | pgla_01K8M3Y0B0E2E8G38C8N1CBKXK |  49.50 | 2025-10-28 00:36:49.123313+00 | 2025-10-28 00:36:49.123313+00 | {"payment_id": "p_123"}
(1 row)

-- Now, this discrepency will show up in the rollup, and it will tell us how much it's off by:
SELECT
    metadata ->> 'payment_id' AS payment_id,
    sum(amount) AS sum
FROM pgledger_entries_view
WHERE account_id =:'user1_receivables_id'
GROUP BY 1
HAVING sum(amount) != 0;
 payment_id | sum  
------------+------
 p_123      | 0.50
(1 row)

-- Continuing the example, let's issue a partial refund of the payment. When we
-- issue the refund, we move the money into the pending_outbound account to
-- hold it until we get confirmation that it was sent
SELECT * FROM pgledger_create_transfer(
    :'user1_available_id',
    :'user1_pending_outbound_id',
    20.00,
    metadata => '{"payment_id": "p_123"}'
);
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |           event_at            |        metadata         
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+-------------------------------+-------------------------
 pglt_01K8M3Y0B4E5TA0E2MDZ7YZ35Q | pgla_01K8M3Y0B0E2E8G38C8N1CBKXK | pgla_01K8M3Y0B0EJB8N305PZ3JW4W5 |  20.00 | 2025-10-28 00:36:49.123976+00 | 2025-10-28 00:36:49.123976+00 | {"payment_id": "p_123"}
(1 row)

-- Once we get confirmation that that refund was sent, We can move the money
-- back to the user's external account (e.g. their credit/debit card). The
-- metadata can be whatever JSON we want, so we can include as many fields as
-- will be helpful:
SELECT * FROM pgledger_create_transfer(
    :'user1_pending_outbound_id',
    :'user1_external_id',
    20.00,
    event_at => '2025-07-21T12:45:54.123Z',
    metadata => '{"payment_id": "p_123",
        "webhook_id": "webhook_123"}'
);
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |          event_at          |                       metadata                       
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+----------------------------+------------------------------------------------------
 pglt_01K8M3Y0B4EWZTG4ZR2VEJ2KYS | pgla_01K8M3Y0B0EJB8N305PZ3JW4W5 | pgla_01K8M3Y0AYFZ1BZN63V0H8EENB |  20.00 | 2025-10-28 00:36:49.124347+00 | 2025-07-21 12:45:54.123+00 | {"payment_id": "p_123", "webhook_id": "webhook_123"}
(1 row)

-- Metadata gives us a powerful way to query the ledger, For example, we can
-- track the history of a specific payment through the various accounts which
-- can help us understand the state of a payment or account:
SELECT
    e.transfer_id,
    a.name,
    e.amount
FROM pgledger_entries_view e
INNER JOIN pgledger_accounts_view a ON e.account_id = a.id
WHERE e.metadata ->> 'payment_id' = 'p_123'
ORDER BY 1;
           transfer_id           |          name          | amount 
---------------------------------+------------------------+--------
 pglt_01K8M3Y0B1ENRV6VNFR6JMAXQD | user1.external         | -50.00
 pglt_01K8M3Y0B1ENRV6VNFR6JMAXQD | user1.receivables      |  50.00
 pglt_01K8M3Y0B3EZ89BYV9W8K4FS4H | user1.receivables      | -49.50
 pglt_01K8M3Y0B3EZ89BYV9W8K4FS4H | user1.available        |  49.50
 pglt_01K8M3Y0B4E5TA0E2MDZ7YZ35Q | user1.available        | -20.00
 pglt_01K8M3Y0B4E5TA0E2MDZ7YZ35Q | user1.pending_outbound |  20.00
 pglt_01K8M3Y0B4EWZTG4ZR2VEJ2KYS | user1.pending_outbound | -20.00
 pglt_01K8M3Y0B4EWZTG4ZR2VEJ2KYS | user1.external         |  20.00
(8 rows)

-- And then we can visualize that data in various ways. For example, we can
-- take the previous query and display in a column-oriented view, making it
-- really easy to see the flow of money:
SELECT
    e.transfer_id,
    a.name,
    e.amount
FROM pgledger_entries_view e
INNER JOIN pgledger_accounts_view a ON e.account_id = a.id
WHERE e.metadata ->> 'payment_id' = 'p_123'
ORDER BY 1
\crosstabview transfer_id name amount
           transfer_id           | user1.external | user1.receivables | user1.available | user1.pending_outbound 
---------------------------------+----------------+-------------------+-----------------+------------------------
 pglt_01K8M3Y0B1ENRV6VNFR6JMAXQD |         -50.00 |             50.00 |                 |                       
 pglt_01K8M3Y0B3EZ89BYV9W8K4FS4H |                |            -49.50 |           49.50 |                       
 pglt_01K8M3Y0B4E5TA0E2MDZ7YZ35Q |                |                   |          -20.00 |                  20.00
 pglt_01K8M3Y0B4EWZTG4ZR2VEJ2KYS |          20.00 |                   |                 |                 -20.00
(4 rows)

-- We can even get fancier and sum the entries for each account in the table:
WITH entries AS (
    SELECT
        e.transfer_id,
        a.name,
        e.amount
    FROM pgledger_entries_view e
    INNER JOIN pgledger_accounts_view a ON e.account_id = a.id
    WHERE e.metadata ->> 'payment_id' = 'p_123'
)
SELECT * FROM (
    SELECT * FROM entries
    UNION
    SELECT
        '--- SUMS ---' AS transfer_id,
        name,
        sum(amount)
    FROM entries
    GROUP BY 1, 2
)
ORDER BY transfer_id
\crosstabview transfer_id name amount
           transfer_id           | user1.external | user1.receivables | user1.available | user1.pending_outbound 
---------------------------------+----------------+-------------------+-----------------+------------------------
 pglt_01K8M3Y0B1ENRV6VNFR6JMAXQD |         -50.00 |             50.00 |                 |                       
 pglt_01K8M3Y0B3EZ89BYV9W8K4FS4H |                |            -49.50 |           49.50 |                       
 pglt_01K8M3Y0B4E5TA0E2MDZ7YZ35Q |                |                   |          -20.00 |                  20.00
 pglt_01K8M3Y0B4EWZTG4ZR2VEJ2KYS |          20.00 |                   |                 |                 -20.00
 --- SUMS ---                    |         -30.00 |              0.50 |           29.50 |                   0.00
(5 rows)

