-- This file contains the sql queries plus their output, but we set the filetype to sql for better syntax highlighting
-- vim: set filetype=sql:

-- This is a fully working example script that shows how to use pgledger
--
-- Note that it uses `\gset` to store sql responses as variables. For example,
-- `\gset foo_` creates variables for each column in the response like
-- `foo_col1`, `foo_col2`, etc. These variables can then be used like
-- `:'foo1_col`.
-- The entire script can be passed to psql. If you are running postgres via the
-- pgledger docker compose, you can run this script with:
--
--   cat basic-example.sql | \
--     docker compose exec --no-TTY postgres psql -U pgledger --echo-queries --no-psqlrc
--
-- We're going to simulate a simple payment flow. First, we create our accounts:
SELECT id FROM pgledger_create_account('user1.external', 'USD') \gset user1_external_
SELECT id FROM pgledger_create_account('user1.receivables', 'USD') \gset user1_receivables_
-- Note that we may want to prevent some accounts from going negative or positive:
SELECT id FROM pgledger_create_account('user1.available', 'USD', allow_negative_balance => false) \gset user1_available_
SELECT id FROM pgledger_create_account('user1.pending_outbound', 'USD') \gset user1_pending_outbound_
-- We can query accounts to see what they looks like at the beginning.
SELECT * FROM pgledger_accounts_view
WHERE id IN (:'user1_external_id', :'user1_available_id');
               id                |      name       | currency | balance | version | allow_negative_balance | allow_positive_balance | metadata |          created_at           |          updated_at
---------------------------------+-----------------+----------+---------+---------+------------------------+------------------------+----------+-------------------------------+-------------------------------
 pgla_01KBE8WV6PE2BSZHVKDD5TSEBZ | user1.external  | USD      |       0 |       0 | t                      | t                      |          | 2025-12-02 00:55:12.852705+00 | 2025-12-02 00:55:12.852705+00
 pgla_01KBE8WV6QFFA9HJVQQFSZWY69 | user1.available | USD      |       0 |       0 | f                      | t                      |          | 2025-12-02 00:55:12.855693+00 | 2025-12-02 00:55:12.855693+00
(2 rows)

-- The first step in the flow is a $50 payment is created and we are waiting for funds to arrive:
SELECT * FROM pgledger_create_transfer(:'user1_external_id',:'user1_receivables_id', 50.00);
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |           event_at            | metadata
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+-------------------------------+----------
 pglt_01KBE8WV6SEDFBB5EY1SDH8VTW | pgla_01KBE8WV6PE2BSZHVKDD5TSEBZ | pgla_01KBE8WV6QESATM17SHW189Q0H |  50.00 | 2025-12-02 00:55:12.856421+00 | 2025-12-02 00:55:12.856421+00 |
(1 row)

-- Next, the funds arrive in our account, so we remove them from receivables and make them available:
SELECT * FROM pgledger_create_transfer(:'user1_receivables_id',:'user1_available_id', 50.00);
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |           event_at            | metadata
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+-------------------------------+----------
 pglt_01KBE8WV6TEJN8WXVS7QACJ5ZT | pgla_01KBE8WV6QESATM17SHW189Q0H | pgla_01KBE8WV6QFFA9HJVQQFSZWY69 |  50.00 | 2025-12-02 00:55:12.858091+00 | 2025-12-02 00:55:12.858091+00 |
(1 row)

-- Now, we can query the accounts and see the balances. We aren't waiting on
-- any more funds, so the receivables balance is 0:
SELECT balance FROM pgledger_accounts_view
WHERE id =:'user1_receivables_id';
 balance
---------
    0.00
(1 row)

-- And we can see the entries for the receivables account:
SELECT * FROM pgledger_entries_view
WHERE account_id =:'user1_receivables_id'
ORDER BY account_version;
               id                |           account_id            |           transfer_id           | amount | account_previous_balance | account_current_balance | account_version |          created_at           |           event_at            | metadata
---------------------------------+---------------------------------+---------------------------------+--------+--------------------------+-------------------------+-----------------+-------------------------------+-------------------------------+----------
 pgle_01KBE8WV6SFH3BBDNNJ4DT7AMA | pgla_01KBE8WV6QESATM17SHW189Q0H | pglt_01KBE8WV6SEDFBB5EY1SDH8VTW |  50.00 |                     0.00 |                   50.00 |               1 | 2025-12-02 00:55:12.856421+00 | 2025-12-02 00:55:12.856421+00 |
 pgle_01KBE8WV6TEPTV5AHRG3FNWSY1 | pgla_01KBE8WV6QESATM17SHW189Q0H | pglt_01KBE8WV6TEJN8WXVS7QACJ5ZT | -50.00 |                    50.00 |                    0.00 |               2 | 2025-12-02 00:55:12.858091+00 | 2025-12-02 00:55:12.858091+00 |
(2 rows)

-- Continuing the example, let's issue a partial refund of the payment. When we
-- issue the refund, we move the money into the pending_outbound account to
-- hold it until we get confirmation that it was sent
SELECT * FROM pgledger_create_transfer(:'user1_available_id',:'user1_pending_outbound_id', 20.00);
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |           event_at            | metadata
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+-------------------------------+----------
 pglt_01KBE8WV6VECBT3C6EJRRMP0QV | pgla_01KBE8WV6QFFA9HJVQQFSZWY69 | pgla_01KBE8WV6QFYTBY62RVFBVFXEY |  20.00 | 2025-12-02 00:55:12.859018+00 | 2025-12-02 00:55:12.859018+00 |
(1 row)

-- Once we get confirmation that that refund was sent, We can move the money
-- back to the user's external account (e.g. their credit/debit card). Often,
-- this confirmation will come as a webhook or bank file or similar, so we can
-- record the event time in the confirmation separately from the time we record
-- the ledger transfer (event_at vs created_at). We can also record extra metadata
-- as JSON that helps us tie it all together:
SELECT *
FROM
    pgledger_create_transfer(
        :'user1_pending_outbound_id',
        :'user1_external_id',
        20.00,
        event_at => '2025-07-21T12:45:54.123Z',
        metadata => '{"webhook_id": "webhook_123"}'
    );
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |          event_at          |           metadata
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+----------------------------+-------------------------------
 pglt_01KBE8WV6VF9QTK93YH2ABHPBH | pgla_01KBE8WV6QFYTBY62RVFBVFXEY | pgla_01KBE8WV6PE2BSZHVKDD5TSEBZ |  20.00 | 2025-12-02 00:55:12.859495+00 | 2025-07-21 12:45:54.123+00 | {"webhook_id": "webhook_123"}
(1 row)

-- Now, we can query the current state. The external account has -$30 ($50
-- payment minus $20 refund) and our account for the user has $30. Nothing is
-- in flight, so the receivables and pending accounts are 0.
SELECT
    name,
    balance
FROM pgledger_accounts_view
WHERE id IN (:'user1_external_id',:'user1_receivables_id',:'user1_available_id',:'user1_pending_outbound_id');
          name          | balance
------------------------+---------
 user1.external         |  -30.00
 user1.receivables      |    0.00
 user1.available        |   30.00
 user1.pending_outbound |    0.00
(4 rows)

-- Next, we can simulate an unexpected case. Let's say we initiate a payment
-- for $10 but we only receive $8 (e.g. due to unexpected fees):
SELECT * FROM pgledger_create_transfer(:'user1_external_id',:'user1_receivables_id', 10.00);
               id                |         from_account_id         |          to_account_id          | amount |          created_at           |           event_at            | metadata
---------------------------------+---------------------------------+---------------------------------+--------+-------------------------------+-------------------------------+----------
 pglt_01KBE8WV6WECMBEZF249Z4355D | pgla_01KBE8WV6PE2BSZHVKDD5TSEBZ | pgla_01KBE8WV6QESATM17SHW189Q0H |  10.00 | 2025-12-02 00:55:12.860049+00 | 2025-12-02 00:55:12.860049+00 |
(1 row)

SELECT * FROM pgledger_create_transfer(:'user1_receivables_id',:'user1_available_id', 8.00);
               id                |         from_account_id         |          to_account_id          | amount |          created_at          |           event_at           | metadata
---------------------------------+---------------------------------+---------------------------------+--------+------------------------------+------------------------------+----------
 pglt_01KBE8WV6WF6RB5VFWQSPC9KQ6 | pgla_01KBE8WV6QESATM17SHW189Q0H | pgla_01KBE8WV6QFFA9HJVQQFSZWY69 |   8.00 | 2025-12-02 00:55:12.86047+00 | 2025-12-02 00:55:12.86047+00 |
(1 row)

-- Now, we can see that our receivables balance is not $0 like we expect:
SELECT balance FROM pgledger_accounts_view
WHERE id =:'user1_receivables_id';
 balance
---------
    2.00
(1 row)

-- And we can look at the entries to figure out what happened:
SELECT * FROM pgledger_entries_view
WHERE account_id =:'user1_receivables_id'
ORDER BY account_version;
               id                |           account_id            |           transfer_id           | amount | account_previous_balance | account_current_balance | account_version |          created_at           |           event_at            | metadata
---------------------------------+---------------------------------+---------------------------------+--------+--------------------------+-------------------------+-----------------+-------------------------------+-------------------------------+----------
 pgle_01KBE8WV6SFH3BBDNNJ4DT7AMA | pgla_01KBE8WV6QESATM17SHW189Q0H | pglt_01KBE8WV6SEDFBB5EY1SDH8VTW |  50.00 |                     0.00 |                   50.00 |               1 | 2025-12-02 00:55:12.856421+00 | 2025-12-02 00:55:12.856421+00 |
 pgle_01KBE8WV6TEPTV5AHRG3FNWSY1 | pgla_01KBE8WV6QESATM17SHW189Q0H | pglt_01KBE8WV6TEJN8WXVS7QACJ5ZT | -50.00 |                    50.00 |                    0.00 |               2 | 2025-12-02 00:55:12.858091+00 | 2025-12-02 00:55:12.858091+00 |
 pgle_01KBE8WV6WEKJ9BJFA9VBQ3JXM | pgla_01KBE8WV6QESATM17SHW189Q0H | pglt_01KBE8WV6WECMBEZF249Z4355D |  10.00 |                     0.00 |                   10.00 |               3 | 2025-12-02 00:55:12.860049+00 | 2025-12-02 00:55:12.860049+00 |
 pgle_01KBE8WV6WFB8B7ASYCB5ZDD9W | pgla_01KBE8WV6QESATM17SHW189Q0H | pglt_01KBE8WV6WF6RB5VFWQSPC9KQ6 |  -8.00 |                    10.00 |                    2.00 |               4 | 2025-12-02 00:55:12.86047+00  | 2025-12-02 00:55:12.86047+00  |
(4 rows)

-- We can also see that the `allow_negative_balance => false` flag on our
-- available account prevents transfers which are more than the current
-- balance:
SELECT * FROM pgledger_create_transfer(:'user1_available_id', :'user1_pending_outbound_id', 50.00);
ERROR:  Account (id=pgla_01KBE8WV6QFFA9HJVQQFSZWY69, name=user1.available) does not allow negative balance
CONTEXT:  PL/pgSQL function pgledger_check_account_balance_constraints(pgledger_accounts) line 5 at RAISE
SQL statement "SELECT pgledger_check_account_balance_constraints(from_account)"
PL/pgSQL function pgledger_create_transfers(transfer_request[],timestamp with time zone,jsonb) line 50 at PERFORM
SQL statement "SELECT * FROM pgledger_create_transfers(
        transfer_requests => array[(from_account_id, to_account_id, amount)::TRANSFER_REQUEST],
        event_at => event_at,
        metadata => metadata
    )"
PL/pgSQL function pgledger_create_transfer(text,text,numeric,timestamp with time zone,jsonb) line 4 at RETURN QUERY
